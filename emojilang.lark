stmt: (_simple_stmt | _compound_stmt)* NEWLINE

_simple_stmt: _small_stmt

_small_stmt: assignment_stmt | flow_stmt | print_stmt | declare_stmt

assignment_stmt: name "=" (exp | test)

declare_stmt: "decl" (_multipleassignment_stmt | name) ("," (_multipleassignment_stmt | name))*

flow_stmt: break_stmt | continue_stmt

break_stmt: "break"

continue_stmt: "continue"

print_stmt: "print" "(" (ESCAPED_STRING | exp) ")" 

_compound_stmt: if_stmt | while_stmt | for_stmt

if_stmt: EIF "(" test ")" "{" suite "}" (EELIF "(" test ")"  "{" suite "}")* (EELSE "{" suite "}")?

while_stmt: "while" "(" for_test ")" "{" suite "}"

for_stmt: "for" "(" for_decl ";" for_test";" for_updates ")" "{" suite "}"

for_decl: (declare_stmt | assignment_stmt)?

for_test: test?

for_updates: _multipleassignment_stmt?

_multipleassignment_stmt: assignment_stmt ("," assignment_stmt)?

suite: (_simple_stmt | _compound_stmt)* NEWLINE

exp: (multiplyexp|logicalexpr) ((EMULT|EDIVIDE|EMOD) (multiplyexp|logicalexpr))*

multiplyexp: (_argument|logicalexpr) ((EPLUS|EMINUS) (_argument|logicalexpr))*

logicalexpr: logicalexpr binarylogicalop logicalexpr 
              | unarylogicalop logicalexpr
              | "(" logicalexpr ")"|exp

binarylogicalop: EAND|EOR

unarylogicalop: ENOT


test: exp (_comp_op exp)*

_comp_op: ELESS | EGREA | EEQU | EGREAE | ELESSE | ENOTEQ

_modulo_op: EMOD

_argument: name|number|("(" exp ")")


name: /[a-zA-z_][a-zA-Z0-9_]*/
%import common.SIGNED_NUMBER
%import common.WS
%import common.NEWLINE
%import common.ESCAPED_STRING
number: SIGNED_NUMBER
EIF: "if"
EELIF: "elif"
EELSE: "else"
EPLUS: "+"
EMINUS: "-"
EMULT: "*"
EDIVIDE: "/"
ELESS: "<"
EGREA: ">"
EEQU: "=="|"is"
EGREAE: ">="
ELESSE: "<="
ENOTEQ: "!="|"is not"

EAND: "and"|"&&"
EOR: "or"|"||"
EXOR: "xor"|"^"
ENOT: "not"|"!"
EIN: "in"|"<-"
ENOTIN: "not in"|"<->"
EMOD: "%"| "mod"


%ignore WS